# Архитектурная спецификация проекта «Умный планировщик дня»

## 1. Цель проекта

Создать приложение, которое принимает список дел, анализирует их с помощью LLM-модели, формирует персонализированный план на день на основе определенных статей, объясняет свои рекомендации и учится на правках пользователя.

---

## 2. Основные функции

### 2.1 Ввод дел на день

* **Название задачи** — пользователь указывает название задачи
* **Категория** — выбор категории для задачи
* **Эмоциональный окрас** — указание эмоциональной характеристики задачи
* **Добавление задач после генерации** — возможность добавлять новые дела после формирования списка от ИИ-ассистента

### 2.2 Умное планирование

* **Составление плана на день с помощью LLM-модели** — автоматическое создание расписания на основе списка задач
* **Распределение по биоритмам** — автоматическое распределение задач по времени суток:
  * Утро
  * День
  * Вечер
* **Обоснование каждой рекомендации** — для каждой задачи предоставляется объяснение, почему она была размещена в определенное время (например, «почему это утром?»)
* **Перегенерация плана** — возможность заново сгенерировать план, если результат не устраивает

### 2.3 Вывод результата

* **Готовый план на день** — отображение сформированного расписания
* **Визуальное разделение** — план разделен на блоки утро/день/вечер, возможно с указанием времени
* **Ручная коррекция** — возможность вручную редактировать план, перемещать задачи между временными блоками
* **Выявление хронотипа** — система определяет, является ли пользователь совой или жаворонком

### 2.4 Персонализация

* **Учет ручных правок** — редактирование плана вручную влияет на будущие рекомендации системы
* **Определение хронотипа** — со временем система автоматически определяет хронотип пользователя (сова/жаворонок) на основе его поведения и предпочтений

### 2.5 Ответ на вопрос "Почему?"

* **Кнопка с вопросом** — сверху списка дел есть кнопка со знаком вопроса, которая открывает список статей, на основе которых осуществлялось распределение задач
* **Список источников** — отображение статей, использованных для формирования рекомендаций
* **Обратная связь по источникам** — возможность нажать кнопку "не доверять источнику", если пользователь не согласен с автором статьи (это влияет на будущие рекомендации)
* **Переход к статье** — возможность перейти по ссылке на статью и ознакомиться с материалом

---

## 3. Общая архитектура

Приложение построено по **модульной архитектуре**, где каждый модуль отвечает за свою зону ответственности. Это упрощает расширение, тестирование и замену отдельных частей.

Основные слои:

1. **UI Layer (интерфейс)**
2. **Domain Layer (логика приложения)**
3. **LLM Layer (работа с моделью)**
4. **Data Layer (хранилище данных)**

---

## 4. Модули и их обязанности

### 4.1 UI Module

Отвечает за визуальную часть приложения.

**Функции:**

* Форма добавления задач (название, категория, эмоциональный окрас).
* Просмотр сгенерированного плана (утро / день / вечер).
* Кнопки:

  * «Сгенерировать план»
  * «Перегенерировать»
  * «+ Добавить задачу»
  * «? Источники»
* Возможность редактировать задачи вручную.
* Кнопка «не доверять источнику» в разделе статей.

**Взаимодействие:**

* Передаёт данные в Domain Layer.
* Получает план и отображает его пользователю.

---

### 4.2 Domain Module

Главный модуль, управляющий всей логикой.

**Функции:**

* Валидация входных данных (пустые поля и т.д.).
* Формирование структуры задач.
* Передача данных в LLM Module.
* Получение плана и адаптация под формат UI.
* Обработка действий пользователя:

  * добавление новых задач
  * изменение времени задач
  * перенос заданий
* Запоминание поведения пользователя для персонализации.

**Взаимодействие:**

* Получает данные от UI.
* Запрашивает план у LLM.
* Сохраняет информацию в Data Module.

---

### 4.3 LLM Module

Отдельный слой для общения с моделью.

**Функции:**

* Формирование промптов.
* Обработка ответов модели.
* Генерация:

  * расписания
  * объяснений «почему»
  * списка источников
* Учет пользовательской истории (хронотип, предпочтения).

**Важно:**
Этот модуль независимо от интерфейса — можно заменить модель или API без изменения других частей.

---

### 4.4 Data Module

Отвечает за хранение всего, что связано с пользовательскими данными.

**Сохраняет:**

* список задач
* историю правок пользователя
* предпочтения (перенос задач, хронотип)
* кэш ответов и источников
* флаги «не доверять источнику»

**Варианты реализации:**

* локально: JSON/SQLite
* облачно: Firebase / Supabase / PostgreSQL

---

## 5. Поток данных (цепочка действий)

### 1. Пользователь вводит задачи → UI

### 2. UI отправляет список задач → Domain

### 3. Domain подготавливает данные → LLM

### 4. LLM создаёт план и объяснения → Domain

### 5. Domain комбинирует план + историю пользователя → UI

### 6. Пользователь вносит правки → UI → Domain → Data

### 7. Domain обновляет модель персонализации → Data

### 8. При следующей генерации это учитывается → LLM

---

## 6. Основные сущности (структуры данных)

```md
Task:
  id: string
  title: string
  category: string
  mood: string
  preferred_time: (утро/день/вечер or null)

PlanItem:
  task_id: string
  time_block: string  # утро/день/вечер
  justification: string # объяснение
  
UserProfile:
  chronotype: "lark" | "owl" | null
  task_shifting_history: {task_id: [time_blocks]}
  disliked_sources: [source_id]
  
Source:
  id: string
  title: string
  link: string
  trust: boolean
```

---

## 7. Возможные технологии

### Frontend:

* Web: React / Vue / Svelte
* Mobile: Flutter / React Native

### Backend:

* Python (FastAPI / Flask)
* Node.js (Express / Nest.js)

### Хранилище:

* SQLite / PostgreSQL / Supabase
* или просто JSON на старте

### LLM API:

* OpenAI
* OpenRouter
* Local LLM через Ollama

---

## 8. Модульные преимущества

* Каждый модуль можно менять отдельно:
  UI → новый дизайн
  LLM → другая модель
  Data → перенос в базу
* Удобна для масштабирования.
* Легко тестировать каждый модуль отдельно.

---